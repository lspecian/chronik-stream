# Raft Consensus Issue Analysis: Why Commits Aren't Happening

## Executive Summary

After deep investigation, I've identified that the **root cause** is NOT the protobuf serialization issue we've been fighting. That's a symptom, not the disease. The fundamental issue is an **architectural mismatch** between:

1. **TiKV Raft's expectations** (prost 0.11 codec)
2. **Our gRPC layer** (tonic + prost 0.13)
3. **Message flow between Raft state machine and network layer**

## The Real Problem: Message Flow is Broken

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Raft Message Flow                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  1. Leader election happens ✓                                    │
│     - PartitionReplica.new() → raw_node with ConfState          │
│     - TiKV Raft Progress tracker populated ✓                     │
│     - Leader elected via natural election ✓                      │
│                                                                   │
│  2. Proposal submitted ✓                                         │
│     - replica.propose(data) → raw_node.propose() ✓              │
│     - Entry added to Raft log ✓                                 │
│                                                                   │
│  3. Ready state processed ✓                                      │
│     - Background tick loop calls replica.tick() ✓                │
│     - replica.ready() extracts messages ✓                        │
│                                                                   │
│  4. Messages sent via gRPC ✗ BROKEN                             │
│     - Messages serialized with prost 0.11 (raft crate) ✓        │
│     - Sent via tonic gRPC (prost 0.13) ✓                         │
│     - Received by RPC server ✗ FAILS                             │
│     - Deserialization with prost 0.11 ✗ VERSION CONFLICT         │
│                                                                   │
│  5. Step RPC handling ✗ BROKEN                                  │
│     - RaftServiceImpl.step() receives proto::RaftMessage ✓       │
│     - Attempts to decode as raft::Message ✗ FAILS                │
│     - Error: prost::Message trait not implemented ✗              │
│                                                                   │
│  6. Commit never happens ✗                                       │
│     - Without successful Step RPC, followers don't ack           │
│     - Without acks, leader can't commit (no quorum)              │
│     - Proposals stuck forever waiting for commit                 │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

## Why This is Fundamentally Broken

### The Prost Version Conflict

```rust
// In chronik-raft/Cargo.toml
[dependencies]
raft = { version = "0.7", features = ["prost-codec"] }
# ↑ Uses prost 0.11 internally

tonic = { workspace = true }  # Uses prost 0.13
prost = { workspace = true }  # prost 0.13

# Our workaround attempt:
prost-011 = { package = "prost", version = "0.11" }  # Alias
```

### Why The Alias Doesn't Work

```rust
// In client.rs (serialization)
use prost_011::Message as ProstMessage011;
let msg_bytes = msg.encode_to_vec();  // ✓ Works - calls raft::Message.encode_to_vec()

// In rpc.rs (deserialization)
use prost_011::Message as ProstMessage011;
let raft_msg: RaftMessage = ProstMessage011::decode(&req.message[..])?;
// ✗ FAILS: "RaftMessage: prost::message::Message is not satisfied"
```

**Why it fails:**
1. `raft::prelude::Message` (RaftMessage) implements `prost::Message` **from prost 0.11** (internal to raft crate)
2. We're trying to call `prost_011::Message::decode()` which expects the trait from **our aliased prost 0.11**
3. These are **different types** despite having the same version number (different crate instances)
4. Rust's type system correctly rejects this as incompatible traits

## Investigation Findings

### 1. Tick Loop is Working ✓

**Evidence from `group_manager.rs:482-599`:**
```rust
pub fn spawn_tick_loop(&self) {
    let handle = tokio::spawn(async move {
        while !shutdown.load(Ordering::Relaxed) {
            for ((topic, partition), replica) in &replicas_snapshot {
                // ✓ Ticking replicas
                replica.tick()?;

                // ✓ Processing ready states
                let (messages, committed) = replica.ready().await?;

                // ✓ Attempting to send messages
                for msg in messages {
                    raft_client.send_message(topic, partition, to, msg).await?;
                    // ✗ THIS IS WHERE IT FAILS (silently logged as warning)
                }
            }
        }
    });
}
```

**Status:** Working correctly. Messages are being generated by Raft.

### 2. Message Generation is Working ✓

**Evidence from `replica.rs:500-644`:**
```rust
pub async fn ready(&self) -> Result<(Vec<Message>, Vec<Entry>)> {
    if node.has_ready() {
        let mut ready = node.ready();

        info!(
            "ready() EXTRACTING for {}-{}: immediate_msgs={}, persisted_msgs={}, entries={}, committed={}",
            self.topic, self.partition,
            ready.messages().len(),              // ✓ Messages present
            ready.persisted_messages().len(),    // ✓ Vote messages present
            ready.entries().len(),
            ready.committed_entries().len()
        );

        // Collect messages from ready state
        let immediate_messages = ready.take_messages();        // Leader messages
        let persisted_messages = ready.take_persisted_messages();  // Follower vote requests

        // ... merge and return
    }
}
```

**Status:** Working correctly. TiKV Raft is generating AppendEntries, RequestVote messages.

### 3. Message Serialization is Working ✓

**Evidence from `client.rs:64-178`:**
```rust
pub async fn send_message(&self, topic: &str, partition: i32, to: u64, msg: RaftMessage_) -> Result<()> {
    // ✓ Serialization works
    let msg_bytes = {
        use prost_011::Message as ProstMessage011;
        msg.encode_to_vec()  // Uses raft::Message's built-in prost 0.11 implementation
    };

    // ✓ gRPC call succeeds
    let raft_msg = proto::RaftMessage {
        topic: topic.to_string(),
        partition,
        message: msg_bytes,
    };

    client.step(raft_msg).await?;  // ✓ Network call succeeds
}
```

**Status:** Working correctly. Bytes are valid prost 0.11 encoded data.

### 4. Step RPC Reception is Broken ✗

**Evidence from `rpc.rs:183-238`:**
```rust
async fn step(&self, request: Request<proto::RaftMessage>) -> Result<Response<StepResponse>, Status> {
    let req = request.into_inner();

    // ✓ Received the gRPC request
    debug!("Step message for {}-{}: {} bytes", req.topic, req.partition, req.message.len());

    // ✓ Found the replica
    let replica = self.get_replica(&req.topic, req.partition)?;

    // ✗ DESERIALIZATION FAILS HERE
    let raft_msg: RaftMessage = {
        use prost_011::Message as ProstMessage011;
        match ProstMessage011::decode(&req.message[..]) {  // ✗ TRAIT NOT IMPLEMENTED
            Ok(msg) => msg,
            Err(e) => {
                error!("Step: failed to decode message: {}", e);
                return Ok(Response::new(StepResponse {
                    success: false,
                    error: format!("Failed to decode message: {}", e),
                }));
            }
        }
    };
}
```

**Status:** BROKEN. Cannot deserialize because trait mismatch.

### 5. Consequence: No Quorum, No Commits ✗

**What happens:**
1. Leader generates AppendEntries messages → ✓
2. Messages serialized and sent via gRPC → ✓
3. Followers receive messages → ✓
4. Followers fail to deserialize → ✗
5. Followers return error response → ✗
6. Leader doesn't get acks → ✗
7. Leader can't reach quorum → ✗
8. Entries never committed → ✗
9. Proposals timeout after 30 seconds → ✗

## Root Cause Analysis

The fundamental issue is that **we cannot use two different versions of prost** in the same call chain:

```
┌────────────────────────────────────────────────────────────┐
│                  Prost Version Conflict                     │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  raft crate (dependency)                                    │
│    └─ Compiled with prost 0.11                              │
│       └─ raft::Message implements prost::Message v0.11      │
│                                                              │
│  chronik-raft (our code)                                    │
│    ├─ Uses tonic (requires prost 0.13)                      │
│    └─ Tries to use prost 0.11 for raft::Message            │
│       └─ ✗ Trait incompatibility: different crate instances │
│                                                              │
│  Attempted workaround:                                       │
│    prost-011 = { package = "prost", version = "0.11" }      │
│       └─ ✗ Creates NEW prost 0.11 instance                  │
│          └─ ✗ NOT the same as raft's internal prost 0.11   │
│             └─ ✗ Trait mismatch still occurs                │
│                                                              │
└────────────────────────────────────────────────────────────┘
```

## Why Previous "Solutions" Failed

### Attempt 1: Downgrade prost and tonic
- **What we tried:** `prost = "0.11"`, `tonic = "0.10"`
- **Why it failed:** `tonic 0.10` uses `prost 0.12` (not 0.11)
- **Result:** Version conflict moved, not solved

### Attempt 2: Alias prost 0.11
- **What we tried:** `prost-011 = { package = "prost", version = "0.11" }`
- **Why it failed:** Creates a NEW crate instance, not the same as raft's internal one
- **Result:** Trait still doesn't match

### Attempt 3: Find compatible tonic version
- **What we tried:** Search for `tonic` version using `prost 0.11`
- **Why it failed:** No such version exists (`tonic 0.8` uses `prost 0.11`, but too old for our needs)
- **Result:** Incompatible API surface

## Solutions (Ordered by Viability)

### Option A: Use rust-protobuf instead of prost for gRPC ⭐ RECOMMENDED

**Approach:**
1. Switch `raft` crate to use `protobuf-codec` (default, uses rust-protobuf)
2. Generate gRPC services using rust-protobuf instead of tonic/prost
3. Use `grpcio` (rust-protobuf based gRPC) instead of tonic

**Pros:**
- ✅ Single protobuf ecosystem (no version conflicts)
- ✅ Well-tested with TiKV projects (TiKV, PingCAP use this stack)
- ✅ Better performance (grpcio uses C++ gRPC core)

**Cons:**
- ❌ Requires rewriting gRPC layer (RaftServiceImpl, RaftClient)
- ❌ Different API than tonic (more imperative, less async/await friendly)

**Effort:** High (2-3 days)

### Option B: Manual Protobuf Serialization/Deserialization

**Approach:**
1. Keep `raft` with `prost-codec`
2. Manually serialize/deserialize `raft::Message` to/from bytes
3. Don't rely on prost traits in our code

**Example:**
```rust
// Serialization (client.rs)
let msg_bytes = {
    // Use raft::Message's internal encode method directly
    let mut buf = Vec::new();
    msg.encode(&mut buf)?;  // This is from raft's prost 0.11
    buf
};

// Deserialization (rpc.rs)
let raft_msg = {
    // Parse bytes directly without using trait
    raft::prelude::Message::decode(req.message.as_slice())?
};
```

**Pros:**
- ✅ Minimal code changes
- ✅ Keeps tonic/prost 0.13 for gRPC
- ✅ No dependency version changes

**Cons:**
- ❌ Relies on internal raft crate methods (may be unstable)
- ❌ Less type-safe (manual byte manipulation)

**Effort:** Low (1 day)

### Option C: Upgrade to tikv/raft 0.8+ (if available)

**Approach:**
1. Check if newer `raft` versions support `prost 0.13`
2. Upgrade `raft` dependency
3. Fix any API changes

**Pros:**
- ✅ Solves version conflict at source
- ✅ Keeps tonic/prost stack

**Cons:**
- ❌ May not exist (`raft 0.7` is latest stable)
- ❌ API breaking changes likely
- ❌ Unproven stability

**Effort:** Unknown (need to check if version exists)

### Option D: Fork raft crate and patch for prost 0.13

**Approach:**
1. Fork `tikv/raft`
2. Update internal prost dependency to 0.13
3. Use forked version

**Pros:**
- ✅ Full control over dependencies

**Cons:**
- ❌ Maintenance burden (need to sync upstream changes)
- ❌ Diverges from upstream (hard to get community fixes)
- ❌ May break TiKV compatibility

**Effort:** High (ongoing maintenance)

## Recommendation

**Implement Option B first (Manual Serialization)** as a quick fix to unblock development, then **plan migration to Option A (rust-protobuf)** for production.

### Phase 1: Quick Fix (Option B)
1. Update `client.rs` to use `msg.encode()` directly
2. Update `rpc.rs` to use `Message::decode()` directly
3. Test with 3-node cluster
4. Verify commits happen

**Timeline:** 1 day

### Phase 2: Proper Solution (Option A)
1. Switch `raft` to `protobuf-codec`
2. Replace tonic with grpcio
3. Regenerate proto files with rust-protobuf
4. Rewrite RaftServiceImpl and RaftClient
5. Full integration testing

**Timeline:** 2-3 days

## Testing Strategy

### Verification Steps

1. **Single-node commit test**
   ```bash
   # Should commit immediately (no replication needed)
   cargo test test_single_node_quick_debug
   ```

2. **Multi-node message exchange test**
   ```bash
   # Start 3 nodes, verify messages are received
   RUST_LOG=debug cargo run -- --raft
   # Check logs for:
   # - "Sending Raft message" (client.rs)
   # - "Step message for" (rpc.rs)
   # - "Raft RPC succeeded" (client.rs)
   ```

3. **Multi-node commit test**
   ```bash
   # Propose entry, verify commit with quorum
   ./test_raft_multi_partition_e2e.py
   ```

4. **Leader election test**
   ```bash
   # Kill leader, verify new leader elected
   ./test_raft_leader_failover.py
   ```

## Next Steps

1. **Immediate:** Implement Option B (manual serialization) to fix the deadlock
2. **Short-term:** Verify commits work in 3-node cluster
3. **Medium-term:** Plan migration to Option A (rust-protobuf + grpcio)
4. **Long-term:** Consider contributing prost 0.13 support upstream to tikv/raft

## Conclusion

The protobuf serialization issue is **solvable but requires careful architectural decisions**. The current approach of trying to bridge two prost versions is fundamentally flawed due to Rust's strict type system treating different crate instances as incompatible.

The quick fix (Option B) will unblock development immediately, while the proper solution (Option A) aligns us with the TiKV ecosystem's proven architecture.
